# -*- coding: utf-8 -*-
"""3DSSF_Task_III.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kXEpzRNVbVjS-vqX5zTpHDUkEx1CSN8q
"""

pip install open3d==0.12.0

!pip install chart_studio

import chart_studio.plotly as py
import plotly.graph_objs as go

import numpy as np
import open3d as o3d
import copy
import time
import pandas as pd

from sklearn.neighbors import NearestNeighbors
from open3d.j_visualizer import JVisualizer

from google.colab import output
output.enable_custom_widget_manager()

from google.colab import drive
drive.mount('/content/drive')

ply_a = '/content/drive/MyDrive/fountain_a.ply'
ply_b = '/content/drive/MyDrive/fountain_b.ply'

"""## Utils"""

def best_fit_transform(A, B):
   

    # get number of dimensions
    m = A.shape[1]

    # translate points to their centroids
    centroid_A = np.mean(A, axis=0)
    centroid_B = np.mean(B, axis=0)
    AA = A - centroid_A
    BB = B - centroid_B

    # rotation matrix
    H = np.dot(AA.T, BB) # covariance matrix
    U, S, Vt = np.linalg.svd(H)
    R = np.dot(Vt.T, U.T)

    # special reflection case
    if np.linalg.det(R) < 0:
       Vt[m-1,:] *= -1
       R = np.dot(Vt.T, U.T)

    # R x A + t = B
    # translation
    t = centroid_B.T - np.dot(R,centroid_A.T)

    # homogeneous transformation
    T = np.identity(m+1)
    T[:m, :m] = R
    T[:m, m] = t

    return T, R, t


def nearest_neighbor(src, dst):
   

    neigh = NearestNeighbors(n_neighbors=1)
    neigh.fit(dst)
    distances, indices = neigh.kneighbors(src, return_distance=True)
    return distances.ravel(), indices.ravel()


def icp(A, B, init_pose=None, max_iterations=1000, tolerance=0.001):
   

    # get number of dimensions
    m = A.shape[1]

    # make points homogeneous, copy them to maintain the originals
    src = np.ones((m+1,A.shape[0]))
    dst = np.ones((m+1,B.shape[0]))
    src[:m,:] = np.copy(A.T)
    dst[:m,:] = np.copy(B.T)

    # apply the initial pose estimation
    if init_pose is not None:
        src = np.dot(init_pose, src)

    prev_error = 0

    for i in range(max_iterations):
        # find the nearest neighbors between the current source and destination points
        distances, indices = nearest_neighbor(src[:m,:].T, dst[:m,:].T)

        # compute the transformation between the current source and nearest destination points
        T,_,_ = best_fit_transform(src[:m,:].T, dst[:m,indices].T)

        # update the current source
        src = np.dot(T, src)

        # check error
        mean_error = np.mean(distances)
        if np.abs(prev_error - mean_error) < tolerance:
            break
        prev_error = mean_error

    # calculate final transformation
    T,_,_ = best_fit_transform(A, src[:m,:].T)

    return T, distances, i

def tr_icp(A, B, init_pose=None, max_iterations=1000, tolerance=0.001):
   

    # get number of dimensions
    m = A.shape[1]

    # make points homogeneous, copy them to maintain the originals
    src = np.ones((m+1,A.shape[0]))
    dst = np.ones((m+1,B.shape[0]))
    src[:m,:] = np.copy(A.T)
    dst[:m,:] = np.copy(B.T)

    # apply the initial pose estimation
    if init_pose is not None:
        src = np.dot(init_pose, src)

    prev_error = 0

    for i in range(max_iterations):
        # find the nearest neighbors between the current source and destination points
        distances, indices = nearest_neighbor(src[:m,:].T, dst[:m,:].T)
        paired_points = sorted([(distances[i], indices[i], i) for i in range(0, len(distances))])
        paired_points_array = np.array(paired_points).astype(int)
        paired_points_array = paired_points_array[:int(paired_points_array.shape[0]/2), :]
        # compute the transformation between the current source and nearest destination points
        T,_,_ = best_fit_transform(src[:m, paired_points_array[:, 2]].T, dst[:m, paired_points_array[:, 1]].T)

        # update the current source
        src = np.dot(T, src)

        # check error
        mean_error = np.mean(distances)
        if np.abs(prev_error - mean_error) < tolerance:
            break
        prev_error = mean_error

    # calculate final transformation
    T,_,_ = best_fit_transform(A, src[:m,:].T)

    return T, distances, i

pcd_a = o3d.io.read_point_cloud(ply_a)
pcd_b = o3d.io.read_point_cloud(ply_b)

def draw_geometries(geometries):
    graph_objects = []

    for geometry in geometries:
        geometry_type = geometry.get_geometry_type()
        
        if geometry_type == o3d.geometry.Geometry.Type.PointCloud:
            points = np.asarray(geometry.points)
            colors = None
            if geometry.has_colors():
                colors = np.asarray(geometry.colors)
            elif geometry.has_normals():
                colors = (0.5, 0.5, 0.5) + np.asarray(geometry.normals) * 0.5
            else:
                geometry.paint_uniform_color((1.0, 0.0, 0.0))
                colors = np.asarray(geometry.colors)

            scatter_3d = go.Scatter3d(x=points[:,0], y=points[:,1], z=points[:,2], mode='markers', marker=dict(size=1, color=colors))
            graph_objects.append(scatter_3d)

        if geometry_type == o3d.geometry.Geometry.Type.TriangleMesh:
            triangles = np.asarray(geometry.triangles)
            vertices = np.asarray(geometry.vertices)
            colors = None
            if geometry.has_triangle_normals():
                colors = (0.5, 0.5, 0.5) + np.asarray(geometry.triangle_normals) * 0.5
                colors = tuple(map(tuple, colors))
            else:
                colors = (1.0, 0.0, 0.0)
            
            mesh_3d = go.Mesh3d(x=vertices[:,0], y=vertices[:,1], z=vertices[:,2], i=triangles[:,0], j=triangles[:,1], k=triangles[:,2], facecolor=colors, opacity=0.50)
            graph_objects.append(mesh_3d)
        
    fig = go.Figure(
        data=graph_objects,
        layout=dict(
            scene=dict(
                xaxis=dict(visible=False),
                yaxis=dict(visible=False),
                zaxis=dict(visible=False)
            )
        )
    )
    fig.show()

def rotation_matrix(axis, theta):
    axis = axis/np.sqrt(np.dot(axis, axis))
    a = np.cos(theta/2.)
    b, c, d = -axis*np.sin(theta/2.)

    return np.array([[a*a+b*b-c*c-d*d, 2*(b*c-a*d), 2*(b*d+a*c)],
                  [2*(b*c+a*d), a*a+c*c-b*b-d*d, 2*(c*d-a*b)],
                  [2*(b*d-a*c), 2*(c*d+a*b), a*a+d*d-b*b-c*c]])

from sklearn.metrics import mean_squared_error

def get_metrics(T, R, t):
    R_measure = T[:3, :3]
    T_measure = T[:3, 3]
    eul_measure = rot2eul(R_measure)
    eul_def = rot2eul(R)
    ang_dist = np.linalg.norm(eul_def - eul_measure)
    mse_translation = mean_squared_error(T_measure, t)
    return ang_dist, mse_translation

def rot2eul(R):
    beta = -np.arcsin(R[2,0])
    alpha = np.arctan2(R[2,1]/np.cos(beta),R[2,2]/np.cos(beta))
    gamma = np.arctan2(R[1,0]/np.cos(beta),R[0,0]/np.cos(beta))
    return np.array((alpha, beta, gamma))

dim = 3                                     # number of dimensions of the points
noise_sigma = .01                           # standard deviation error to be added
translation = .4                            # max translation of the test set
rotation = .4    
N = 10                                    # number of random points in the dataset

def pcd_changes(pcd, translation):
    new_pcd = copy.deepcopy(pcd)

    # Translate
    new_pcd = new_pcd.translate(translation)

    # Rotate
    R = rotation_matrix(np.random.rand(dim), np.random.rand()*rotation)
    new_pcd.rotate(R, center=(0, 0, 0))

    # Add noise
    new_pcd_points = np.asarray(new_pcd.points)
    new_pcd_points += np.random.randn(new_pcd_points.shape[0], new_pcd_points.shape[1]) * noise_sigma
    new_pcd.points = o3d.utility.Vector3dVector(new_pcd_points)

    return new_pcd, R

def my_print(header, x):
    print(f"{header}:\n")
    try:
        for row in x:
            print(' '.join(map(lambda x: "{:.3f}\t".format(x), row)))
    except:
        print(np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x}))

"""## Visualization

### Original
"""

o3d.visualization.draw_geometries = draw_geometries # replace function
o3d.visualization.draw_geometries([pcd_a + pcd_b])

"""### After transformation"""

pcd_b_changed, R = pcd_changes(pcd_b, [0.05, 0.05, 0.05])

o3d.visualization.draw_geometries = draw_geometries # replace function
o3d.visualization.draw_geometries([pcd_a + pcd_b_changed])

"""## Algorithms

### ICP
"""

start = time.time()
T, distances, iterations = icp(np.asarray(pcd_b_changed.points), np.asarray(pcd_a.points), tolerance=0.000001)
print(time.time() - start)
print(f"iterations - {iterations}")

pcd_b_icp = copy.deepcopy(pcd_b_changed).transform(T)

o3d.visualization.draw_geometries = draw_geometries # replace function
o3d.visualization.draw_geometries([pcd_a + pcd_b_icp])

"""### Tr-ICP"""

start = time.time()
T, distances, iterations = tr_icp(np.asarray(pcd_b_changed.points), np.asarray(pcd_a.points), tolerance=0.000001)
print(time.time() - start)
print(f"iterations - {iterations}")

pcd_b_tricp = copy.deepcopy(pcd_b_changed).transform(T)

o3d.visualization.draw_geometries = draw_geometries # replace function
o3d.visualization.draw_geometries([pcd_a + pcd_b_tricp])

"""## Reports"""

algorithms = {'Tr-ICP': tr_icp, "ICP": icp}
t_vectors = [[0.01, 0.02, 0.03], [0.04, 0.05, 0.06], [0.07, 0.08, 0.09], [0.03, 0.05, 0.01], [0.06, 0.04, 0.01]]
def make_report(pcd_a, pcd_b, t):
  report = {"algorithm": [], "time": [], "iterations": [], "mse_translation": [], "angular_error": []}
  pcd_b_changed, R = pcd_changes(pcd_b, t)
  for algorithm in algorithms.keys():
      start = time.time()
      T, distances, iterations = algorithms[algorithm](np.asarray(pcd_b_changed.points), np.asarray(pcd_a.points), tolerance=0.00001)
      report["algorithm"].append(algorithm)
      report["time"].append(time.time() - start)
      report["iterations"].append(iterations)
      ang_dist, mse_translation = get_metrics(T, R, t)
      report["mse_translation"].append(mse_translation)
      report["angular_error"].append(ang_dist)
  my_print("Rotation matrix", R)
  print('\n')
  my_print("Translation vector", np.array(t))
  df = pd.DataFrame(report)
  print('\n Report:')
  print(df)

for t in t_vectors:
    make_report(pcd_a, pcd_b, t)
    print("\n---------------------------------\n")

"""# 3D Reconstruction

http://graphics.stanford.edu/data/3Dscanrep/
"""

import os

ply_path = "/content/drive/MyDrive/bunny_data/"

files = os.listdir(ply_path)
print(files)
files = [o3d.io.read_point_cloud(ply_path + f) for f in files]
files

pcd_a = files[0]
for i in range(1, len(files)):
    pcd_b = files[i]
    pcd_a_points = np.asarray(pcd_a.points)
    pcd_b_points = np.asarray(pcd_b.points)
    T, distances, iterations = tr_icp(pcd_b_points, pcd_a_points, tolerance=0.000001)
    pcd_a = pcd_a + pcd_b.transform(T)
o3d.io.write_point_cloud("bunny.ply", pcd_a)

from google.colab import files

files.download('bunny.ply')